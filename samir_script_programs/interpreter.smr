#########################
#LEXER
#########################

class Lexer(source: string){

    var pos: number = 0;
    var tokens: List = [];
    var current: String = source[0];

    func __call__() -> List {

        while current != "/0" do {

            match current with
                case " " ->
                    advance(); # Ignore whitespace.
                case "+" -> {
                    add_token(TT_PLUS, "+");
                    advance();
                }
                case "-" -> {
                    add_token(TT_MINUS, "-");
                    advance();
                }
                case "*" -> {
                    add_token(TT_MULTIPLY, "*");
                    advance();
                }
                case "/" -> {
                    add_token(TT_DIV, "/");
                    advance();
                }
                case "(" -> {
                    add_token(TT_L_PAREN, "(");
                    advance();
                }
                case ")" -> {
                    add_token(TT_R_PAREN, ")");
                    advance();
                }
                else -> {
                    if isNumeric(current) then
                        make_number();
                    else 
                        return Error("{current} is an invalid char");
                }
        }

        var end_token: Token = Token(TT_EOF, "EOF");
        tokens.add(end_token);
        return tokens;
    }

    func advance() -> nil {
        if pos + 1 >= len(source) then{
            pos += 1;
            current = "/0";
        }
        else{
            pos += 1;
            current = source[pos];
        }
        
    }

    func add_token(type: number, value: string) -> nil {
        var token: Token = Token(type, value);
        tokens.add(token);
    }

    func make_number() -> nil{
        var number_string: string = "";
        while isNumeric(current) do {
            number_string = number_string + current;
            advance();
        }
        add_token(TT_NUMBER, num(number_string));
    }
}

#########################
#TOKENS AND TOKEN TYPES
#########################

enum {
    TT_NUMBER,
    TT_PLUS,
    TT_MINUS,
    TT_MULTIPLY,
    TT_DIV,
    TT_L_PAREN,
    TT_R_PAREN,
    TT_EOF
}


class Token(type: number, value: string){

    func __str__() -> string{
        return str(value);
    }

}

#########################
#PARSER
#########################

class Parser(tokens: List){
    var current: Token = tokens[0];
    var pos: number = 0;

    var hadError: boolean = false;
    var log: string;

    func __call__() -> Node {
        return expression();
    }

    func expression() -> Node {
        var left: Node = term();

        while current.type == TT_MINUS or
        current.type == TT_PLUS do {
            var op_tok: Token = current;
            advance();
            var right: Node = term();
            left = BinOpNode(left, op_tok, right);
        }

        return left;

    }

    func term() -> Node {
        var left: Node = unary();

        while current.type == TT_MULTIPLY or
        current.type == TT_DIV do {
            var op_tok: Token = current;
            advance();
            var right: Node = unary();
            left = BinOpNode(left, op_tok, right);
        }

        return left;
    }

    func unary() -> Node {
        if current.type == TT_MINUS then {
            var op: string = "-";
            advance();
            var right: Node = unary();
            return UnaryOpNode(op, right);
        }

        return primary();
    }

    func primary() -> Node {
        if current.type == TT_NUMBER then {
            var node: Node = NumberNode(current.value);
            advance();
            return node;
        }

        elif current.type == TT_L_PAREN then {
            advance();
            var expre: Node = expression();
            if current.type != TT_R_PAREN then{
                hadError = true;
                log = "Expected closing ')'";
            }
            advance();
            return GroupingNode(expre);
        }

        hadError = true;
        log = "Invalid syntax";
        return nil;
    }

    func advance(){
        if pos + 1 >= len(tokens) then{
            hadError = true;
            log = "invalid syntax (EOF)";
            return;
        }
        pos += 1;
        current = tokens[pos];
    }

}

#########################
# AST NODES
#########################

class NumberNode(value: number){

    func __str__() -> string {
        return str(value);
    }

    func visit() -> number {
        return value;
    }
}

class GroupingNode(expre: Node){

    func __str__() -> string {
        return "({expre})";
    }

    func visit() -> variant {
        return expre.visit();
    }

    
}

class BinOpNode(left: variant, op: Token, right: variant){

    func __str__() -> string{
        return "({left}{op}{right})";
    }

    func visit() -> number {
        var right_op = right.visit();
        var left_op = left.visit();

        match op.type with
            case TT_PLUS -> return left_op + right_op;
            case TT_MINUS -> return left_op - right_op;
            case TT_MULTIPLY -> return left_op * right_op;
            case TT_DIV -> return left_op / right_op;
    }
}

class UnaryOpNode(op: Token, right: Node){

    func visit() -> number {
        if op == "-" then
            return right.visit() * -1;    
    }

    func __str__() -> string {
        return "{op}({right})" ;
    }

}

#########################
#ERROR HANDLING
#########################

class Error(log: string){}

#########################
#ENTRY POINT
#########################


while true do {

    var source: string = input("> ");
    if source == "" then
        continue;

    var tokens: List = Lexer(source)();
    if typeOf(tokens) == "Error" then {
        println tokens.log;
        continue;
    }

    var parser: Parser = Parser(tokens);
    var AST: Node = parser();
    if parser.hadError then {
        println parser.log;
        continue;
    }

    println AST.visit();

}